% Setup -------------------------------

\documentclass[a4paper]{report}
\usepackage[a4paper, total={6in, 10in}]{geometry}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\usepackage{hyperref}
\usepackage{indentfirst}

\usepackage{graphicx}
\usepackage{titlepic}

% Encoding
%--------------------------------------
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
%--------------------------------------

% Portuguese-specific commands
%--------------------------------------
\usepackage[portuguese]{babel}
%--------------------------------------

% Hyphenation rules
%--------------------------------------
\usepackage{hyphenat}
%--------------------------------------

% Capa do relatório

\title{
	Tolerância a Faltas
	\\ \Large{\textbf{Trabalho Prático}}
	\\ -
	\\ Mestrado em Engenharia Informática
	\\ Universidade do Minho
}

\author{
	\begin{tabular}{ll}
		\textbf{Grupo nº 8}
		\\
		\hline
		PG41080 & João Ribeiro Imperadeiro
        \\
		PG41081 & José Alberto Martins Boticas
		\\
		PG41091 & Nelson José Dias Teixeira
	\end{tabular}
	\vspace{1cm}
	}
	
\date{\today}

\titlepic{
	\vspace{2cm}
	\includegraphics[scale=0.065]{Image/EEUM_logo.png}
}

\begin{document}

\begin{titlepage}
	\maketitle
\end{titlepage}

% Índice

\tableofcontents
\listoffigures

% Introdução

\chapter{Introdução} \label{ch:Introduction}
\large {
	Toda a gente, de uma forma ou de outra, já esteve em contacto com uma loja \textit{online}. Muitos podem mesmo dizer que já dependem deste tipo de serviços para efetuar as suas compras. Por não estarem diretamente relacionadas com uma localização física, estas lojas estão disponíveis para todos, independentemente de onde se encontre fisicamente no mundo.

	Assim, levantam-se alguns problemas relacionados com a implementação destes tipos de serviços, como por exemplo a oferta de um serviço com bom desempenho para todos os clientes, independentemente da sua localização física. Isto leva à necessidade de não depender de apenas um servidor central, distribuindo a disponibilização do serviço por diversos servidores.
	Ora, isto leva a que seja necessário ter cuidados extra nas interações com os clientes, como a manutenção da consistência entre os servidores, para que, no caso em que um destes servidores falhe, o cliente não seja afetado negativamente.

	Posto isto, é-nos proposta a implementação, em \texttt{Java}, de uma versão simplificada de um supermercado \textit{online} distribuído por vários servidores, que por sua vez seja o mais tolerante a faltas possível. Para isso, entre outras ferramentas, será utilizado o protocolo \textit{Spread} para comunicação em grupo, à semelhança do que se sucedeu ao longo das aulas da componente prática desta unidade curricular.

	Relativamente à estrutura do presente documento, é descrito de forma mais detalhada a proposta deste projeto, fazendo-se referência aos requisitos intrínsecos à mesma.
	De seguida, são exibidos todos os aspetos referentes à implementação deste trabalho. Nesta fase, são especificados todos os tópicos alusivos ao cliente, servidor e, ainda, ao \textit{middleware} genérico da aplicação.
	Posteriormente, são evidenciadas todas as valorizações tomadas em consideração no desenvolvimento do mesmo.
	Por fim, são extraídas algumas conclusões da realização deste trabalho, sumariando, globalmente, os objetivos alcançados.
}

\chapter{Descrição do problema e requisitos} \label{ch:ProblemDescriptionRequirements}
\large{
	Tal como foi mencionado no \hyperref[ch:Introduction]{capítulo introdutório} deste documento, o objetivo principal deste projeto prático consiste na implementação em \texttt{Java}, usando o protocolo de comunicação em grupo \textit{Spread}, de um serviço tolerante a faltas.

	Este serviço diz respeito a um supermercado \textit{online} que disponibiliza algumas funcionalidades aos seus clientes. Entra elas destacam-se:
	\begin{itemize}
		\item criar uma encomenda;
		\item iniciar uma compra;
		\item consultar o preço e disponibilidade de um produto;
		\item acrescentar um produto a uma determinada encomenda;
		\item confirmar uma encomenda, indicando se foi concretizada com sucesso.
	\end{itemize}

	O serviço guarda um catálogo contendo uma descrição de cada produto e a quantidade disponível.
	Cada encomenda inclui um ou mais produtos, sendo que só pode ser concretizada com sucesso se todos os produtos estiverem disponíveis.
	Admite-se que existe um tempo limite \texttt{TMAX} para a concretização de uma encomenda. Caso esse tempo seja esgotado e a encomenda ainda não tenha sido efetuada, é cancelada.  Embora seja indesejável, admite-se também que uma encomenda pode ser cancelada unilateralmente pelo sistema.

	Quanto aos requisitos da aplicação são impostos os seguintes:
	\begin{itemize}
		\item par cliente/servidor da interface descrita, replicado para tolerância a faltas;
		\item permitir o armazenamento persistente do estado dos servidores na base de dados \textit{HSQLDB};
		\item transferência de estado para permitir a reposição em funcionamento de servidores sem interrupção do serviço;
		\item implementação de uma interface simplificada para o utilizador, de forma a testar o serviço em causa;
	\end{itemize}

	Tendo em conta todos os pontos referidos acima, procede-se agora à implementação da proposta inerente a este projeto prático.
}

\chapter{Implementação} \label{ch:Implementation}
\large{
	De seguida serão abordadas a forma adotada para implementar várias vertentes deste trabalho. Será apresentado o middleware genérico desenvolvido para servir de base para este trabalho, bem como o uso deste num par cliente/servidor que atinge os objetivos cumpridos.

	\section{\textit{Middleware} genérico} \label{sec:Middleware}
		Se for excluída a lógica de negócio relacionada com o funcionamento do supermercado, temos na essência deste trabalho um conjunto de servidores ligados entre si que gerem uma base de dados em HSQLDB (por recomendação do enunciado). Para além disto, todos os servidores são réplicas perfeitas uns dos outros, ou seja, todos aplicam as mesma alterações às suas bases de dados, o que significa que, na prática, é obtida uma base de dados distribuída por eles. Os papéis dos servidores são simétricos, sendo que qualquer um deles poderá receber pedidos de clientes interessados no serviço disponibilizado.

		Posto isto, foi tomada a decisão de implementar esta arquitetura genérica em classes independentes da lógica de negócio propriamente dita, dando origem a duas classes: ServerConnection e ClientConnection. A primeira é responsável por gerir o conjunto de servidores, sendo iniciada uma instância desta em cada um destes. A segunda é utilizada por clientes para interagir com os servidores de forma transparente.

		Seguidamente, será detalhada cada uma destas classes.

		\subsection{\textit{ServerConnection}} \label{subsec:ServerConnection}
			Como referido atrás, a classe ServerConnection é responsável pela coordenação entre os servidores, gerindo a base de dados de cada um deles e recebendo pedidos de clientes. Para iniciar um destes servidores é necessário indicar a porta onde este estará à espera de pedidos de clientes, o que fazer após ser estabelecida a ligação à base de dados, uma lista de tabelas a ser criada na base de dados, os handlers para lidar com pedidos do cliente e o processamento das atualizações à base de dados.
			
			Quando é iniciado, o servidor conecta-se ao daemon Spread e prepara-se para a receção de mensagens vindas dos restantes servidores do cluster. Após isto, coloca-se num de estado de espera, o qual pode ser interrompido de duas formas:
			\begin{itemize}
				\item se for o primeiro servidor a juntar-se ao cluster, inicializa a base de dados e cria as tabelas especificadas pelo utilizador do middleware. Depois, executa uma função que é fornecida pelo utilizador, dando-lhe oportunidade de inicializar objetos que dependam de uma ligação à base de dados;
				\item caso contrário, fica à espera de receber uma vista da base de dados de um dos servidores que já estão no cluster, o que será detalhado posteriormente. Este servidor não é escolhido ao acaso, dado que é assumida a noção de um servidor primário que, na prática, é o mais antigo do cluster. Enquanto não recebe esta informação, vai acumulando todos os pedidos enviados pelos outros servidores, de forma a poder quando esta é recebida.
			\end{itemize}
		
			Em ambos os casos é inicializada a forma de comunicação com os clientes que, no nosso caso, recorre à framework Atomix, à qual são passados os handlers fornecidos pelo utilizador, os quais estão relacionados com a lógica de negócio.
			
			Voltando ao envio do conteúdo da base de dados para os novos membros, são feitos checkpoint's periódicos da base de dados, de forma a que, no caso de um dos servidores se desconectar e conectar passado algum tempo, ser possível enviar apenas as alterações feitas desde o último checkpoint, em vez da base de dados completa. Isto torna-se mais relevante em bases de dados de maior dimensão.

			\subsubsection{Replicação} \label{sssec:Replication}
				Quanto ao tipo de replicação escolhido para resolver o problema em mãos, acabou por ser adotada a replicação passiva, dado que, por um lado, o cliente só necessita de comunicar com um servidor (o que facilita a sua implementação) e, por outro, a sincronização necessária é muito simplificada pelo uso da framework Spread.

				Quanto à implementação em si, é necessário que o utilizador do middleware forneça os handlers que serão chamados quando chega um pedido do cliente e o que fazer quando chega uma atualização para a base de dados. 
				
				Quando chega um pedido de um cliente, é chamado o respetivo handler e é devolvido um HandlerRes pelo utilizador, que informa o middleware se a informação é para ser enviada diretamente para o cliente (por exemplo, no caso de um GET) ou, no caso de ser necessário fazer alterações à base de dados, se é para passar pelo mecanismo de replicação, isto é, enviada a todos os membros do cluster atomicamente, utilizando o Spread.
				
				Depois disto, quando esta informação é entregue aos servidores, é invocada a função fornecida pelo utilizador correspondente àquele pedido. Esta função poderá efetuar qualquer operação, mas o mais normal será enviar uma atualização para a base de dados. Pelo uso do Spread, é garantido que esta atuaização ocorrerá "em simultâneo" em todos os servidores.
				
				Por fim, é enviada uma resposta ao servidor, se o utilizador assim pretender, e esta resposta será enviada pelo servidor que recebeu o pedido correspondente àquela atualização.

			\subsubsection{Temporizadores} \label{sssec:Timers}
				Como referido acima, os servidores efetuam checkpoints periódicos. Para isso, necessitam de uma primitiva que lhes permita enviar uma mensagem atomicamente para o servidor ao fim de um determinado período de tempo. Para isso, é criada uma thread em cada servidor, que no final do tempo indicado pelo utilizador, envia uma mensagem para todos os membros do cluster. Note-se que isto é apenas feito pelo servidor primário, ou seja, é garantido que ocorre apenas uma vez. Há ainda a possibilidade fazer isto repetidamente, como é o caso dos checkpoints.

			\subsubsection{Comunicação entre servidores} \label{sssec:ServerCommunication}
			\subsubsection{Comunicação com clientes} \label{sssec:ClientCommunication}
		\subsection{\textit{ClientConnection}} \label{subsec:ClientConnection}
	
	\section{Servidor - \textit{Supermarket}} \label{sec:Server}
		A classe \texttt{Supermarket} representa o comportamento de cada um dos servidores, sendo nesta classe que se estabelece as ligações à base de dados e aos outros servidores.
		
		A ligação à base de dados é feita de vários pontos e sempre através de \textit{skeletons}. Assim, existe um \textit{skeleton} para cada carrinho de compras e ainda um outro para o catálogo.
		Desta forma, invoca-se apenas o \textit{skeleton} necessário a cada ação, sem que seja necessário ter total conhecimento dos seus atributos.

		\subsection{Funcionamento} \label{subsec:ServerWorking}
		\subsection{\textit{CartSkeleton}} \label{subsec:ServerCartSkeleton}
		\subsection{\textit{CatalogSkeleton}} \label{subsec:ServerCatalogSkeleton}
	
	\section{Cliente} \label{sec:Client}
		O cliente desta aplicação é responsável por interagir com o \textit{cluster} de servidores, invocando ao mesmo pedidos relacionados com operações do supermercado.
		Esta entidade permite, de certa forma, testar o programa desenvolvido como um todo, verificando, desta forma, a validade das funcionalidades propostas neste projeto.
		Para proceder à conceção e implementação do cliente, foram criados vários menus na aplicação por forma a cobrir todos os casos intrínsecos às funcionalidades da mesma.

		\subsection{Funcionamento} \label{subsec:ClientWorking}
		O cliente inicialmente, no momento da conexão ao \textit{cluster}, especifica as portas referentes ao próprio e, também, as relativas aos servidores, sendo necessário indicar pelo menos uma das portas destes últimos.
		A informação relativa à porta de cada servidor é guardada numa lista para o caso de haver falhas no estabelecimento da conexão entre o cliente e este último. Assim, havendo a indisponibilidade momentânea de um dos servidores, é atribuído outro para o efeito.

		Uma vez estabelecida a conexão entre o cliente e um dos servidores presentes no \textit{cluster}, é apresentado à primeira entidade um menu relativo ao supermercado. Nele estão contidas todas as opções indispensáveis para efetuar as operações descritas no enunciado deste trabalho prático.
		Destas operações destacam-se a consulta do catálogo da aplicação, a criação de um carrinho de compras e ainda a verificação da disponibilidade de um determinado produto.
		É de realçar também que existe um menu alusivo ao carrinho de compras onde se pode concretizar o \textit{checkout} dos produtos selecionados.
		Para além destas, o grupo oferece uma opção extra relativa ao menu do administrador, onde se possibilita a invoção de métodos associados à atualização do catálogo do supermercado.

		\subsection{\textit{CartStub}} \label{subsec:ClientCartStub}
		No que toca ao \textit{stub} do carrinho de compras do presente programa disponibilizam-se 3 métodos distintos, nomeadamente \textit{updateProduct}, \textit{checkout} e \textit{getProducts}.
		Tal como os nomes dos mesmos transparecem, estas funções dizem respeito à atualização de um determinado produto, ao \textit{checkout} dos mesmos e, ainda, à obtenção dos produtos presentes no carrinho.
		Todos estes partilham o mesmo objeto \textit{serializer}, responsável por serializar as mensagens enviadas para um dos servidores da aplicação.
		Para além disso, estão também associados a esta classe \texttt{Java} um identificador referente ao carrinho de compras em causa e um objeto relativo à conexão do cliente ao \textit{cluster} de servidores (\hyperref[subsec:ClientConnection]{\textit{ClientConnection}}).

		\subsection{\textit{CatalogStub}} \label{subsec:ClientCatalogStub}
		Quanto ao \textit{stub} do catálogo, este assemelha-se ao do carrinho de compras a nível de variáveis de instância. Esta classe contém igualmente o serializador de mensagens referido na \hyperref[subsec:ClientCartStub]{secção anterior} e, ainda, o objeto correlacionado à conexão do cliente ao conjunto de servidores.
		Contudo, apesar destas semelhanças, esta classe \texttt{Java} possui, obviamente, funções distintas da mencionada anteriormente.
		O \textit{stub} do catálogo apresenta métodos inerentes não só à sua consulta como também à observação de informações intrínsecas aos produto contidos no próprio (como por exemplo, o preço e a quantidade).
		Mais, por forma a atualizar os dados dos produtos em questão, existe também a possibilidade de invocar métodos alusivos à adição e remoção dos mesmos.
}

\chapter{Valorizações} \label{ch:ProblemDescription}
\large{
	Relativamente ao que é referido no enunciado deste trabalho, são recomendadas algumas valorizações que beneficiam a nota final do mesmo.
	Das valorizações mencionadas, os elementos que compõem este grupo optaram por realizar as seguintes:
	\begin{enumerate}
		\item separação do código relativo ao \textit{middleware} genérico de replicação do código alusivo à aplicação;
		\item garantia do tratamento concorrente de varias operações;
		\item suporte de partições do grupo na ferramenta computacional \textit{Spread};
		\item realização de uma análise de desempenho;
		\item minimização das encomendas canceladas como consequência de faltas ou do funcionamento do mecanismo de replicação;
		\item atualização oportuna do estado dos servidores com recurso ao sistema de base de dados, diminuindo, sempre que possível, o volume da informação copiada.
	\end{enumerate}
}

\chapter{Conclusão} \label{ch:Conclusion}
\large{
	
}

\appendix
\chapter{Observações} \label{ch:Observations}
\begin{itemize}
    \item Documentação \textit{Java} 8:
    \par \textit{\url{https://docs.oracle.com/javase/8/docs/api/}}
	\item \textit{Maven}:
	\par \textit{\url{https://maven.apache.org/}}
	\item \textit{Spread toolkit}:
	\par \textit{\url{http://www.spread.org/index.html}}
	\item \textit{Atomix}:
	\par \textit{\url{https://atomix.io/}}
	\item \textit{HSQLDB}:
	\par \textit{\url{http://hsqldb.org/}}
\end{itemize}

\end{document}